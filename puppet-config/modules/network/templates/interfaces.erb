<% ########################################################################## -%>
<% #  Puppet configuration file                                             # -%>
<% #                                                                        # -%>
<% #  Copyright (C) 2014-2017 EDF S.A.                                      # -%>
<% #  Contact: CCN-HPC <dsp-cspit-ccn-hpc@edf.fr>                           # -%>
<% #                                                                        # -%>
<% #  This program is free software; you can redistribute in and/or         # -%>
<% #  modify it under the terms of the GNU General Public License,          # -%>
<% #  version 2, as published by the Free Software Foundation.              # -%>
<% #  This program is distributed in the hope that it will be useful,       # -%>
<% #  but WITHOUT ANY WARRANTY; without even the implied warranty of        # -%>
<% #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         # -%>
<% #  GNU General Public License for more details.                          # -%>
<% ########################################################################## -%>

#####################################################################
# Network interfaces configuration (Debian Operating System)
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
#####################################################################
# NOTE: This file is automatically generated by puppet.
# Changes to this file will be overwritten periodically by puppet!
#####################################################################
# TEMPLATE: {<%= @name %>}/<%= File.basename(__FILE__) %>}
#####################################################################
<%-
  require 'ipaddr'

  netconfig          = scope['::netconfig']
  defaultgw          = scope['::network::defaultgw']
  bondcfg            = scope['::network::bonding_options']
  bridgecfg          = scope['::network::bridge_options']
  routnet            = scope['::network::routednet']
  ib_mtu             = scope['::network::ib_mtu']
  ib_mode            = scope['::network::ib_mode']
  eth_no_offload_ifs = scope['::network::eth_no_offload_ifs']

  network_gw_set = String.new
  bndprim = String.new
  bndmode = String.new
  routecfg = Hash.new

  # Insert bridged interfaces in the netconfig
  bridgecfg.map do | bridge, value |
    if not netconfig.key?(bridge)
      next
    end
    ports = value['ports']
    ports.each do | port |
      if not netconfig.include?(port)
        netconfig[port] = []
      end
    end
  end

  # Insert bonding slaves interfaces in the netconfig
  bondcfg.map do | bond, value |
    if not netconfig.key?(bond)
      next
    end
    ports = value['slaves']
    ports.each do | port |
      if not netconfig.include?(port)
        netconfig[port] = []
      end
    end
  end

  # Initialization done, starting to actually write the file
-%>

auto lo
iface lo inet loopback
<%-

  # ifupdown is not able to solve dependencies between interfaces (ex: bridges
  # -> bonding -> eth). Therefore, interfaces must be added in the correct order
  # so that all interfaces can initialize properly. To do this, the eth/ib
  # interfaces are selected first. Then, the logical bonding and bridges
  # interfaces are appended.
  netifs = Array.new
  netifs.concat netconfig.keys.select{|k| k =~ /^eth/}.sort
  netifs.concat netconfig.keys.select{|k| k =~ /^ib/}.sort
  netifs.concat netconfig.keys.select{|k| k =~ /^bond/}.sort
  netifs.concat netconfig.keys.select{|k| k =~ /^br/}.sort

  # Iterate over the cards (interface)
  netifs.each do |card|
    ipaddrs = netconfig[card]
    default_gw_set = false
-%>

### <%= card %> Configuration ###
auto <%= card %>
<%-
    # If the card has no IP address, set it in manual mode (typically, this is a
    # bridge port). Otherwise, set it in static mode.
    if ipaddrs.empty?
-%>
iface <%= card %> inet manual
<%-
    else
-%>
iface <%= card %> inet static
<%-
    end

    # Bonding
    if card.include?("bond")
      bondcfg[card]['options'].split(' ').each do | opt |
        opt_key = opt.split('=')[0]
        opt_value = opt.split('=')[1]
        unless opt_value.empty?
-%>
    bond-<%= opt_key + ' ' + opt_value %>
<%-
        end
      end
      slaves = bondcfg[card]['slaves']
-%>
    slaves <%= slaves.join(' ') %>
<%-
      if not ipaddrs.empty?
        # Clean potential IP address from DHCP on slave interfaces
        slaves.each do | slave |
-%>
    pre-up ip addr del <%= ipaddrs[0] %> dev <%= slave %> || true
<%-
        end
      end
    # Bridges
    elsif card.include?("br")
-%>
    bridge_ports <%= bridgecfg[card]['ports'].join(' ') %>
<%-
    end

    main_address = nil
    main_address_has_default_gw = false
    sec_addresses = Array.new()
    unless defaultgw.empty? or default_gw_set
      # Iterate over the IP addresses to find if the default gateway can be set on
      # this card.
      ipaddrs.each do |ipadd|
        # Configure the default gateway if this address is in the same subnet
        begin
          range = IPAddr.new(ipadd)
        rescue
          scope.function_warning(["Invalid IP address: #{ipadd}"])
          next
        end
        addtrg = IPAddr.new(defaultgw)
        if range.include?(addtrg)
          default_gw_set = true
          main_address_has_default_gw = true
          main_address = ipadd
        else
          sec_addresses.push(ipadd)
        end
      end
    end

    # If there is no default gateway on any address of this card, the first
    # is promoted
    if not main_address_has_default_gw and not sec_addresses.empty?
      main_address = sec_addresses.shift
    end

    # If the card has at least an IP address, set it with static address
    # parameter. The other optional addresses are appended with up commands, as
    # documented in:
    #   https://wiki.debian.org/NetworkConfiguration#iproute2_method
    if main_address
-%>
    address <%= main_address %>
<%-
      if main_address_has_default_gw
-%>
    gateway <%= defaultgw %>
<%-
      else
-%>
    # default gateway <%= defaultgw %> not in range for this interface
<%-
      end
    end

    # Apply specific parameters in interfaces is lowlatency netif (IB or similar)
    if card.include?("ib")
-%>
    ib-mode <%= ib_mode %>
    mtu <%= ib_mtu %>
<%-
    end

    # Disable offloading if it has been requested for this interface
    if eth_no_offload_ifs.include?(card)
-%>
    # Offloading disabled
    offload-tx  off
    offload-sg  off
    offload-tso off
<%-
    end

    # Iterate over the secondary and more IP addresses of the card to set them
    # with up/down `ip` commands.
    if not sec_addresses.empty?
      sec_addresses.each do |ipaddr|
-%>
    up   ip addr add <%= ipaddr %> dev $IFACE
    down ip addr del <%= ipaddr %> dev $IFACE
<%-
       end
     end # Address iteration end

     # Card has supplementary routes?
     if routnet.key?(card)
       routnet[card].each do |route|
-%>
    post-up ip route add <%= route %> dev $IFACE
<%-
      end # Routes iteration end
    end
  end # Card iteration end
-%>
