<% ########################################################################## -%>
<% #  Puppet configuration file                                             # -%>
<% #                                                                        # -%>
<% #  Copyright (C) 2014-2017 EDF S.A.                                      # -%>
<% #  Contact: CCN-HPC <dsp-cspit-ccn-hpc@edf.fr>                           # -%>
<% #                                                                        # -%>
<% #  This program is free software; you can redistribute in and/or         # -%>
<% #  modify it under the terms of the GNU General Public License,          # -%>
<% #  version 2, as published by the Free Software Foundation.              # -%>
<% #  This program is distributed in the hope that it will be useful,       # -%>
<% #  but WITHOUT ANY WARRANTY; without even the implied warranty of        # -%>
<% #  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         # -%>
<% #  GNU General Public License for more details.                          # -%>
<% ########################################################################## -%>
#!/bin/bash
#####################################################################
# Script to change NFS HA from master to server
#
#  This script is called by the notify script when keepalived changes
#  the state.
#
#####################################################################
# NOTE: This file is automatically generated by puppet.
# Changes to this file will be overwritten periodically by puppet!
#####################################################################
# TEMPLATE: {<%= @name %>}/<%= File.basename(__FILE__) %>
#####################################################################
# Puppet: mount_points.join(' ')
MOUNTPOINTS='<%= @mount_points.join(' ') %>'
# Puppet: lvm_vg
VGNAME='<%= @lvm_vg %>'
# Puppet: fence_method
FENCE_METHOD='<%= @fence_method %>'
# Puppet: partner
PARTNER='<%= @partner %>'
# Puppet: ip_address
IP_ADDRESS='<%= @ip_address %>'

export LANG=C
export LC_ALL=C

instance_type="${1}"
instance_name="${2}"
target_state="${3}"

current_name="$(basename $0)"

mkdir -p /var/log/hpc_nfs_ha_server
exec 1>> /var/log/hpc_nfs_ha_server/${current_name}.log 2>&1 

function vgtag_get () {
  local tag=''
  tag="$(vgs --noheadings -o vg_tags ${VGNAME} | tr -d ' ')"
  status=$?
  if [[ "x${status}" == "x0" ]]
  then
    logger -st ${current_name}.info "INFO: $(hostname) Read tag '${tag}' from ${VGNAME}"
  else
    logger -st ${current_name}.error "ERROR: $(hostname) Failed to read tag from ${VGNAME}"
  fi
  echo "${tag}"
  return ${status}
}

function vgtag_del () {
  local tag="${1}"
  logger -st ${current_name}.info "INFO: $(hostname) Deleting tag '${tag}' from ${VGNAME}"
  vgchange --deltag "${tag}" "${VGNAME}"
  status=$?
  if [[ "x${status}" != "x0" ]]
  then
    logger -st ${current_name}.error "ERROR: $(hostname) Failed to del tag on ${VGNAME}"
  fi
  return ${status}
}

function vgtag_set () {
  local new_tag="${1}"
  vg_tag="$(vgtag_get)"
  if [ -n "${vg_tag}" ]
  then
    logger -st ${current_name}.info "INFO: $(hostname) Remove all old tags before setting this one"
    for tag in $(echo ${vg_tag} | sed 's/,/ /')
    do
      vgtag_del "${tag}"
    done
  fi
  logger -st ${current_name}.info "INFO: $(hostname) Setting new tag ${new_tag} on ${VGNAME}"
  vgchange --addtag "${new_tag}" "${VGNAME}"
  status=$?
  if [[ "x${status}" != "x0" ]]
  then
    logger -st ${current_name}.error "ERROR: $(hostname) Failed to set tag on ${VGNAME}"
  fi
  return ${status}
}

function vgtag_wait () {
  logger -st ${current_name}.info "INFO: $(hostname) Waiting a minute max for the tag to be empty"
  local i=6
  vg_tag="$(vgtag_get)"
  while [ ${i} -gt 0 -a -n "${vg_tag}" ]
  do
    logger -st ${current_name}.info "INFO: $(hostname) Tag not empty, $(( $i * 10 )) seconds left before giving up."
    let i-=1
    sleep 10
    vg_tag="$(vgtag_get)"
  done
}


function fence_is_off () {
  local node="${1}"
  local method="${2}"
  case "${method}" in
    'CLARA_VIRT')
      logger -st ${current_name}.info "INFO: $(hostname) Using clara virt to check node status"
      state=$(clara virt list | sed -n "s/VM:${node}\s*State:\(\S*\)\s*.*/\1/;T;p")
      logger -st ${current_name}.info "INFO: $(hostname) Node state is ${state}"
      if [[ "x${state}" == "xSHUTOFF" ]]
      then
        status=0
      else
        status=1
      fi
      ;;
    'CLARA_IPMI')
      logger -st ${current_name}.info "INFO: $(hostname) Using clara ipmi to check node status"
      if [[ "$(clara ipmi status ${node} | awk '{print $6}')" == 'off' ]]
      then
        status=0
      else
        status=1
      fi
      ;;
    'DEBUG')
      logger -st ${current_name}.info "WARNING: $(hostname) Using Fake fencing for checking status, DO NOT USE IN PRODUCTION"
      status=0
      ;;
    *)
      logger -st ${current_name}.error "ERROR: $(hostname) Unknown fencing method ${method}."
      status=2
      ;;
  esac
  if [[ "x${status}" == "x0" ]]
  then
      logger -st ${current_name}.info "INFO: $(hostname) Node ${node} is off"
  else
      logger -st ${current_name}.info "INFO: $(hostname) Node ${node} is not off"
  fi
  return ${status}
}

function fence_off () {
  local node="${1}"
  local method="${2}"
  case "${method}" in
    'CLARA_VIRT')
      logger -st ${current_name}.info "INFO: $(hostname) Using clara virt to turn off node"
      clara virt stop --hard "${node}"
      status=$?
      ;;
    'CLARA_IPMI')
      logger -st ${current_name}.info "INFO: $(hostname) Using clara ipmi to turn off node"
      clara ipmi off "${node}"
      status=$?
      ;;
    'DEBUG')
      logger -st ${current_name}.info "WARNING: $(hostname) Using Fake fencing for turning node off, DO NOT USE IN PRODUCTION"
      status=0
      ;;
    *)
      logger -st ${current_name}.error "ERROR: $(hostname) Unknown fencing method ${method}."
      status=2
      ;;
  esac
  if [[ "x${status}" == "x0" ]]
  then
      logger -st ${current_name}.info "INFO: $(hostname) Fencing successfully launched"
  else
      logger -st ${current_name}.info "INFO: $(hostname) Fencing command failed"
  fi
  return ${status}
}
      

# Fence = shutdown partner node to avoid it being up
function fence_partner () {
  logger -st ${current_name}.info "INFO: $(hostname) Fencing partner with method ${FENCE_METHOD}"
  fence_off "${PARTNER}" "${FENCE_METHOD}"
  sleep 10
  if fence_is_off "${PARTNER}" "${FENCE_METHOD}"
  then
    logger -st ${current_name}.info "INFO: $(hostname) Fencing successfull"
  else
    logger -st ${current_name}.error "FATAL ERROR: $(hostname) Fencing failed"
    exit 1
  fi
}


# Active the volume group only if we are able to lock the tag on it
# If this is not possible after about a minute, the partner node is 
# fenced before activating the volume group
function vg_safe_activation () {
  vg_tag="$(vgtag_get)"
  if [[ "x${vg_tag}" != "x$(hostname)" ]]
  then
    logger -st ${current_name}.info "INFO: $(hostname) tag is not the hostname."
    vgtag_wait
    vg_tag="$(vgtag_get)"
    if [[ -n "${vg_tag}" ]]
    then
      logger -st ${current_name}.info "INFO: $(hostname) tag still not empty."
      fence_partner
    else
      logger -st ${current_name}.info "INFO: $(hostname) tag is empty, safely proceeding"
    fi
  else
    logger -st ${current_name}.info "INFO: $(hostname) tag is already the hostname."
  fi
  vgtag_set "$(hostname)"
  logger -st ${current_name}.info "INFO: $(hostname) activating '${VGNAME}'"
  vgchange -a y "${VGNAME}"
  status=$?
  if [[ "x${status}" != "x0" ]]
  then
    logger -st ${current_name}.error "ERROR: $(hostname) Failed to activate ${VGNAME}"
  fi
  return ${status}
}

function are_fs_mounted () {
  local mount_points_list=( "${@}" )
  logger -st ${current_name}.info "INFO: $(hostname) checking mount points ${mount_points_list[@]}"
  status_to_return=0
  for mount_point in "${mount_points_list[@]}"
  do
    if mountpoint -q "${mount_point}"
    then
      logger -st ${current_name}.info "INFO: $(hostname) ${mount_point} is mounted"
    else
      logger -st ${current_name}.error "ERROR: $(hostname) ${mount_point} is not mounted"
      status_to_return=1
    fi
  done
  return ${status_to_return}     
}


function fs_mount_and_export () {
  vg_safe_activation
  for mount_point in ${MOUNTPOINTS}
  do
    if fsck -a "${mount_point}"
    then
      logger -st ${current_name}.info "INFO: $(hostname) fsck success for ${mount_point}"
    else
      logger -st ${current_name}.error "ERROR: $(hostname) fsck failure for ${mount_point}"
    fi
    if mount "${mount_point}"
    then
      logger -st ${current_name}.info "INFO: $(hostname) Mounted ${mount_point}"
    else
      logger -st ${current_name}.error "ERROR: $(hostname) Failed to mount ${mount_point}"
    fi
  done  
  if are_fs_mounted ${MOUNTPOINTS}
  then
    logger -st ${current_name}.info "INFO: $(hostname) Starting nfs-kernel-server"
    systemctl start nfs-kernel-server.service
  else
    logger -st ${current_name}.error "ERROR: $(hostname) Some FS are not properly mounted, not starting NFS"
  fi
}

function fs_unexport_and_umount () {
  logger -st ${current_name}.info "INFO: $(hostname) Stopping nfs-kernel-server"
  systemctl stop nfs-kernel-server.service
  let countdown=3
  while [ ${countdown} -gt 0 ] && are_fs_mounted ${MOUNTPOINTS}
  do
    for mount_point in ${MOUNTPOINTS}
    do
      if umount -f "${mount_point}"
      then
        logger -st ${current_name}.info "INFO: $(hostname) Umounted ${mount_point}"
      else
        logger -st ${current_name}.error "ERROR: $(hostname) Failed to umount ${mount_point}"
      fi
    done
    sleep 1
    let countdown-=1
  done
  if are_fs_mounted ${MOUNTPOINTS}
  then
    logger -st ${current_name}.error "FATAL ERROR: $(hostname) Some FS are still mounted, turning off"
    poweroff
    exit 1
  else
    logger -st ${current_name}.info "INFO: $(hostname) FS unmounted, releasing the volume group"
    vgchange -a n
    vgtag_del "$(hostname)"
  fi
}
  
logger -st ${current_name}.info "INFO: $(hostname) changed state for NFS, the new state is: ${target_state}."
case "${target_state}" in
  "MASTER")
    logger -st ${current_name}.info "INFO: $(hostname) becomes master"
    fs_mount_and_export
  ;;
  "BACKUP")
    logger -st ${current_name}.info "INFO: $(hostname) becomes backup"
    fs_unexport_and_umount
  ;;
  *)
    logger -st ${current_name}.info "INFO: $(hostname) is neither master nor backup"
    fs_unexport_and_umount
  ;;    
esac
